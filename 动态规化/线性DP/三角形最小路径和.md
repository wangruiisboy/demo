# leetcode 120 三角形最小路径和

## 方法一 : 记忆化搜索，空间换时间
> 时间复杂度:O($2^n$) <br>
> 空间复杂度:O(n)
``` python
    class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)

        @cache 
        def dfs(i : int,j:int) -> int:
            if(i == n - 1):
                return triangle[i][j]
            
            # 第一部分
            first = dfs(i+1,j)
            # 第二部分
            second = dfs(i+1,j+1)

            # 计算当前的值
            return triangle[i][j] + min(first,second)
        
        return dfs(0,0)
```


## 方法二：动态规化
> 时间复杂度:O(n) <br>
> 空间复杂度:O(n)


``` python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        # 从倒数第二行开始向上计算
        for i in range(n-2, -1, -1):
            # 遍历当前行的每个元素
            for j in range(i+1):
                # 当前元素加上下一行相邻两个元素中的较小值
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
        # 顶部元素就是最小路径和
        return triangle[0][0]
```
